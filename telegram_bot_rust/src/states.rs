// src/states.rs

use teloxide::macros::DialogueState;
use serde::{Serialize, Deserialize};

// Main dialogue encompassing all bot states
#[derive(DialogueState, Clone, Serialize, Deserialize, Debug, Default)]
#[handler_out(anyhow::Result<()>)] // All handlers for this dialogue must return anyhow::Result<()>
pub enum State {
    #[default]
    Start, // Initial state, or when no specific dialogue is active

    // Captcha process
    #[state(entry_fn = "send_captcha_message")] // Optional: function to call upon entering this state
    WaitingCaptchaAnswer {
        expected_answer: String,
        original_message_id_to_delete: Option<i32>, // To delete the "please solve" message
    },

    // Main menu / Idle after verification
    MainMenu,

    // Settings Dialogues
    WaitingUserSettingsInstruction { original_message_id_to_delete: Option<i32> },
    WaitingUserSettingsTemperature { original_message_id_to_delete: Option<i32> },
    // SelectingTextModel, // Could be a sub-dialogue or handled by callback queries + temp state
    // SelectingImageModel,

    SettingsMenu, // A state to signify user is in the settings menu (after returning from sub-dialogue)

    // Chat Dialogue
    ActiveChat {
        history: Vec<(String, String)>, // role, content (simplified)
        current_model: String,
    },

    // Image Generation Dialogue
    ImageGenerationMenu, // User is viewing the image generation menu
    WaitingImagePrompt {
        image_model: String,
        original_message_id_to_delete: Option<i32>, // To delete the "Enter prompt" message
    },
    // Add more states as needed for other functionalities like subscription purchase, admin actions etc.
}

// Entry function for WaitingCaptchaAnswer state (example)
// This function would be called by the dialogue dispatcher when transitioning to WaitingCaptchaAnswer.
// However, sending messages is usually done in the handler that *causes* the transition.
// So, this entry_fn might be more for logging or setting up internal state if not sending a message.
// For now, let's assume the message is sent by the handler that transitions to this state.
/*
async fn send_captcha_message(
    bot: Bot,
    dialogue: MyDialogue, // MyDialogue is State wrapped in Dialogue<State, Storage>
    (expected_answer, original_message_id): (String, Option<i32>), // Data to pass to the state
) -> anyhow::Result<()> {
    log::info!("Transitioned to WaitingCaptchaAnswer state. Expected: {}", expected_answer);
    // The actual message sending would have happened in the handler that called `dialogue.update(NewState).await`.
    // This entry function is more for logic *after* transition but *before* next user input.
    Ok(())
}
*/

// We'll need to define a storage for dialogues, e.g., MemoryStorage, RedisStorage, etc.
// type MyDialogue = Dialogue<State, MemoryStorage<State>>; // Example for main.rs
// type HandlerResult = Result<(), Box<dyn std::error::Error + Send + Sync>>; // For handler functions
// Teloxide's dptree handlers usually return Result<(), teloxide::RequestError> or a custom error type.
// The `anyhow::Result<()>` in `DialogueState` is for the `#[handler_out]` attribute.
// Individual handlers within the dialogue FSM will conform to this.
// Non-dialogue handlers can still use Result<(), teloxide::RequestError>.

// Note: `teloxide::macros::DialogueState` generates the FSM logic.
// Handlers for each state will be defined elsewhere, typically grouped by functionality.
// e.g., a captcha_handler.rs might contain functions that take `MyDialogue` and `Message`
// and then `match dialogue.state()` to handle specific states like `State::WaitingCaptchaAnswer`.
// Or, using dptree, you can branch based on `dptree::entry().branch(Update::filter_message().branch(State::filter_waiting_captcha_answer().endpoint(handler_fn)))`
// where `State::filter_...` methods are generated by the macro.

// Helper function to get a clean state for a new dialogue
pub fn new_dialogue() -> State {
    State::default() // Or State::Start if that's more appropriate
}
